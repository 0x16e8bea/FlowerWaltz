#pragma kernel Init
#pragma kernel Flock

#include "UnityCG.cginc"
#include "SimplexNoise3D.cginc"

struct Boid
{
	float maxSpeed;
};

RWStructuredBuffer<Boid> boidBuffer;
RWStructuredBuffer<float4> positionBuffer;
RWStructuredBuffer<float4> rotationBuffer;
RWStructuredBuffer<float4> velocityBuffer;
RWStructuredBuffer<float4> attractorBuffer;

float4 attractor;
float deltaTime;
float randomSeed;
float nearbyDist;
int instanceCount;


// Pseudo-random number generation.
// Based on https://github.com/keijiro/Swarm
float Random(uint id, float u)
{
    u = u * 0.0018372 + randomSeed * 0.0023849;
    float v = id * 0.0013345;
    float f = dot(float2(12.9898, 78.233), float2(u, v));
    return frac(43758.5453 * sin(f));
}

// Attractor position with spread parameter.
// Based on https://github.com/keijiro/Swarm
float3 AttractorPosition(uint id)
{
    // Between 0 and 2 pi
    float u = Random(id, 1) * UNITY_PI * 2;
    
    // Between -1 and 1
    float z = Random(id, 2) * 2 - 1;
    
    // Between 0 and 1
    float l = Random(id, 3);
    
    float3 d = float3(float2(cos(u), sin(u)) * sqrt(1 - z * z), z) * sqrt(l);
    return attractor.xyz + d * attractor.w;
}

float map(float value, float min1, float max1, float min2, float max2) {
    // Convert the current value to a percentage.
    // 0% - min1, 100% - max1
    float perc = (value - min1) / (max1 - min1);
    
    // Do the same operation backwards with min2 and max2.
    return perc * (max2 - min2) + min2;
}

//float3 Seperate(Boid boid, Boid tempBoid) {
    //return (boid.pos - tempBoid.pos);
    
//    return (boid.pos - tempBoid.pos) * abs(dot(boid.velocity, tempBoid.velocity)) * abs(dot(tempBoid.pos - boid.pos, tempBoid.velocity));

//}

[numthreads(64, 1, 1)]
void Init(uint id : SV_DispatchThreadID) {
	Boid boid = boidBuffer[id.x];
    float4 p = positionBuffer[id.x];
    
	p.xyz = AttractorPosition(id);
    p.w = 1;
    
    attractorBuffer[id.x] = float4(p.xyz,1);
    positionBuffer[id.x] = p;
    velocityBuffer[id.x] = float4(0,0,0,0);
    rotationBuffer[id.x] = float4(0,0,0,0);
}


[numthreads(64,1,1)]
void Flock (uint3 id : SV_DispatchThreadID)
{
	Boid boid = boidBuffer[id.x];
    float4 p = positionBuffer[id.x];
    float4 v = velocityBuffer[id.x];
    float4 r = rotationBuffer[id.x];
    float4 a = 0;
    a.xyz = AttractorPosition(id);

	//separation
	float3 separation = float3(0.0, 0.0, 0.0);

	//alignment
	float3 alignment = float3(0.0, 0.0, 0.0);

	//cohesion
	float3 cohesion = attractor;
	float3 tempCohesion = float3(0.0, 0.0, 0.0);

    float tempSpeed = 0;
	uint nearbyCount = 0;

    [loop]
	for (int i = 0; i < int(instanceCount); i++)	{
		if (i != int(id.x))
		{
			float3 tempBoid = positionBuffer[i].xyz;
			if (length(p.xyz - tempBoid) < nearbyDist)
			{
				separation += p.xyz - tempBoid;

				alignment += velocityBuffer[i].xyz;

				tempCohesion += p.xyz;

				nearbyCount++;
			}
		}
	}

	if (nearbyCount > 0)
	{
		alignment *= 1 / nearbyCount;
		tempCohesion *= 1 / nearbyCount;
	}

    cohesion += tempCohesion;

	float3 direction = separation + normalize(a - p);
	
	positionBuffer[id.x].xyz += v * deltaTime;
	velocityBuffer[id.x].xyz += direction * deltaTime;
    rotationBuffer[id.x].xyz += v * deltaTime;

}




